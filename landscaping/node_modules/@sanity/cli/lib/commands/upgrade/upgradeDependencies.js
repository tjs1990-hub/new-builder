"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = upgradeDependencies;

var _util = _interopRequireDefault(require("util"));

var _path = _interopRequireDefault(require("path"));

var _fs = require("fs");

var _boxen = _interopRequireDefault(require("boxen"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _semver = _interopRequireDefault(require("semver"));

var _lodash = require("lodash");

var _readLocalManifest = _interopRequireDefault(require("@sanity/util/lib/readLocalManifest"));

var _findSanityModuleVersions = _interopRequireDefault(require("../../actions/versions/findSanityModuleVersions"));

var _printVersionResult = require("../versions/printVersionResult");

var _debug = _interopRequireDefault(require("../../debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rimraf = _util.default.promisify(_rimraf.default);

async function upgradeDependencies(args, context) {
  const {
    output,
    workDir,
    yarn,
    chalk
  } = context;
  const {
    extOptions,
    argsWithoutOptions
  } = args;
  const modules = argsWithoutOptions.slice();
  const {
    range,
    tag
  } = extOptions;
  const saveExact = extOptions['save-exact'];
  const targetRange = tag || range;

  if (range && tag) {
    throw new Error('Both --tag and --range specified, can only use one');
  }

  if (range && !_semver.default.validRange(range)) {
    throw new Error(`Invalid semver range "${range}"`);
  } // Find which modules needs update according to the target range


  const versions = await (0, _findSanityModuleVersions.default)(context, {
    target: targetRange,
    includeCli: false
  });
  const allNeedsUpdate = versions.filter(mod => mod.needsUpdate);
  (0, _debug.default)('In need of update: %s', allNeedsUpdate.map(mod => mod.name).join(', '));
  const needsUpdate = modules.length === 0 ? allNeedsUpdate : allNeedsUpdate.filter(outOfDate => modules.indexOf(outOfDate.name) !== -1);
  const semverBreakingUpgrades = versions.filter(hasSemverBreakingUpgrade);
  const baseMajorUpgrade = semverBreakingUpgrades.find(mod => mod.name === '@sanity/base');
  const majorUpgrades = semverBreakingUpgrades.filter(mod => mod.name !== '@sanity/base');
  schedulePrintMajorUpgrades({
    baseMajorUpgrade,
    majorUpgrades
  }, context); // If all modules are up-to-date, say so and exit

  if (needsUpdate.length === 0) {
    const specified = modules.length === 0 ? 'All' : 'All *specified*';
    context.output.print(`${chalk.green('✔')} ${specified} Sanity modules are at latest compatible versions`);
    return;
  } // Ignore modules that are pinned, but give some indication that this has happened


  const pinned = needsUpdate.filter(mod => mod.isPinned);
  const nonPinned = needsUpdate.filter(mod => !mod.isPinned);
  const pinnedNames = pinned.map(mod => mod.name).join(`\n - `);

  if (nonPinned.length === 0) {
    context.output.warn(`${chalk.yellow('⚠')} All modules are pinned to specific versions, not upgrading:\n - ${pinnedNames}`);
    return;
  }

  if (pinned.length > 0) {
    context.output.warn(`${chalk.yellow('⚠')} The follow modules are pinned to specific versions, not upgrading:\n - ${pinnedNames}`);
  } // Forcefully remove non-symlinked module paths to force upgrade


  await Promise.all(nonPinned.map(mod => deleteIfNotSymlink(_path.default.join(context.workDir, 'node_modules', mod.name.replace(/\//g, _path.default.sep))))); // Replace versions in `package.json`

  const versionPrefix = saveExact ? '' : '^';
  const oldManifest = await (0, _readLocalManifest.default)(workDir);
  const newManifest = nonPinned.reduce((target, mod) => {
    if (oldManifest.dependencies && oldManifest.dependencies[mod.name]) {
      target.dependencies[mod.name] = mod.latestInRange === 'unknown' ? oldManifest.dependencies[mod.name] : versionPrefix + mod.latestInRange;
    }

    if (oldManifest.devDependencies && oldManifest.devDependencies[mod.name]) {
      target.devDependencies[mod.name] = mod.latestInRange === 'unknown' ? oldManifest.devDependencies[mod.name] : versionPrefix + mod.latestInRange;
    }

    return target;
  }, oldManifest); // Write new `package.json`

  const manifestPath = _path.default.join(context.workDir, 'package.json');

  await writeJson(manifestPath, newManifest, {
    spaces: 2
  }); // Run `yarn install`

  const flags = extOptions.offline ? ['--offline'] : [];
  const cmd = ['install'].concat(flags);
  (0, _debug.default)('Running yarn %s', cmd.join(' '));
  await yarn(cmd, { ...output,
    rootDir: workDir
  });
  context.output.print('');
  context.output.print(`${chalk.green('✔')} Modules upgraded:`);
  const {
    versionLength,
    formatName
  } = (0, _printVersionResult.getFormatters)(nonPinned);
  nonPinned.forEach(mod => {
    const current = chalk.yellow((0, _lodash.padStart)(mod.installed, versionLength));
    const latest = chalk.green(mod.latestInRange);
    context.output.print(`${formatName(mod.name)} ${current} → ${latest}`);
  });
}

function writeJson(filePath, data) {
  return _fs.promises.writeFile(filePath, `${JSON.stringify(data, null, 2)}\n`);
}

async function deleteIfNotSymlink(modPath) {
  const stats = await _fs.promises.lstat(modPath).catch(_lodash.noop);

  if (!stats || stats.isSymbolicLink()) {
    return null;
  }

  return rimraf(modPath);
}

function hasSemverBreakingUpgrade(mod) {
  return !_semver.default.satisfies(mod.latest, `^${mod.installed}`) && _semver.default.gt(mod.latest, mod.installed);
}

function getMajorUpgradeText(mods, chalk) {
  const modNames = mods.map(mod => `${mod.name} (v${_semver.default.major(mod.latest)})`).join('\n - ');
  return [`The following modules has new major versions\n`, `released and will have to be manually upgraded:\n\n`, ` - ${modNames}\n\n`, chalk.yellow('⚠'), ` Note that major versions can contain backwards\n`, `  incompatible changes and should be handled with care.`].join('');
}

function getMajorStudioUpgradeText(mod, chalk) {
  const prev = _semver.default.major(mod.installed);

  const next = _semver.default.major(mod.latest);

  return ['There is now a new major version of Sanity Studio!', '', 'Read more about the new version and how to upgrade:', chalk.blueBright(`https://www.sanity.io/changelog/studio?from=v${prev}&to=v${next}`)].join('\n');
}

function schedulePrintMajorUpgrades({
  baseMajorUpgrade,
  majorUpgrades
}, {
  chalk,
  output
}) {
  if (majorUpgrades.length === 0 && !baseMajorUpgrade) {
    return;
  }

  process.on('beforeExit', () => {
    output.print(''); // Separate previous output with a newline

    if (baseMajorUpgrade) {
      output.warn((0, _boxen.default)(getMajorStudioUpgradeText(baseMajorUpgrade, chalk), {
        borderColor: 'green',
        padding: 1
      }));
      return;
    }

    output.warn((0, _boxen.default)(getMajorUpgradeText(majorUpgrades, chalk), {
      borderColor: 'yellow',
      padding: 1
    }));
  });
}