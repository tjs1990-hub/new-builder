"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findSanityModuleVersions;

var _path = _interopRequireDefault(require("path"));

var _promisePropsRecursive = _interopRequireDefault(require("promise-props-recursive"));

var _semverCompare = _interopRequireDefault(require("semver-compare"));

var _getLatestVersion = _interopRequireDefault(require("get-latest-version"));

var _dynamicRequire = _interopRequireDefault(require("../../util/dynamicRequire"));

var _getLocalVersion = _interopRequireDefault(require("../../util/getLocalVersion"));

var _package = _interopRequireDefault(require("../../../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * The `sanity upgrade` command should only be responsible for upgrading the
 * _studio_ related dependencies. Modules like @sanity/block-content-to-react
 * shouldn't be upgraded using the same tag/range as the other studio modules.
 *
 * We don't have a guaranteed list of the "studio modules", so instead we
 * explicitly exclude certain modules from being upgraded.
 */
const PACKAGES_TO_EXCLUDE = ['@sanity/ui', '@sanity/icons', '@sanity/logos', '@sanity/block-content-to-react', '@sanity/block-content-to-html', '@sanity/block-tools'];
const defaultOptions = {
  includeCli: true
};

async function findSanityModuleVersions(context, opts = {}) {
  const {
    spinner
  } = context.output;
  const options = { ...defaultOptions,
    ...opts
  };
  const {
    target,
    includeCli
  } = options; // Declared @sanity modules and their wanted version ranges in package.json

  const sanityModules = filterSanityModules(getLocalManifest(context.workDir)); // Figure out the latest versions which match the wanted range

  const resolveOpts = {
    includeCli,
    target
  };
  const spin = spinner('Resolving latest versions').start();
  const versions = await (0, _promisePropsRecursive.default)(buildPackageArray(sanityModules, context.workDir, resolveOpts));
  const packages = Object.values(versions);
  spin.stop();
  return packages.map(mod => {
    mod.needsUpdate = target === 'latest' ? (0, _semverCompare.default)(mod.installed, mod.latest) === -1 : mod.installed !== mod.latestInRange;
    return mod;
  });
}

function getLocalManifest(workDir) {
  try {
    return (0, _dynamicRequire.default)(_path.default.join(workDir, 'package.json'));
  } catch (err) {
    return {};
  }
}

function filterSanityModules(manifest) {
  const dependencies = { ...manifest.dependencies,
    ...manifest.devDependencies
  };
  return Object.keys(dependencies).filter(mod => mod.startsWith('@sanity/')).filter(mod => !PACKAGES_TO_EXCLUDE.includes(mod)).sort().reduce((versions, dependency) => {
    versions[dependency] = dependencies[dependency];
    return versions;
  }, {});
}

function buildPackageArray(packages, workDir, options = {}) {
  const {
    includeCli,
    target
  } = options;
  const modules = [];

  if (includeCli) {
    const [cliMajor] = _package.default.version.split('.');

    const latest = tryFindLatestVersion(_package.default.name, target || `^${cliMajor}`);
    modules.push({
      name: _package.default.name,
      installed: _package.default.version,
      latest: latest.then(versions => versions.latest),
      latestInRange: latest.then(versions => versions.latestInRange),
      isPinned: false
    });
  }

  return [...modules, ...Object.keys(packages).map(pkgName => {
    const latest = tryFindLatestVersion(pkgName, target || packages[pkgName] || 'latest');
    return {
      name: pkgName,
      installed: (0, _getLocalVersion.default)(pkgName, workDir) || '<missing>',
      latest: latest.then(versions => versions.latest),
      latestInRange: latest.then(versions => versions.latestInRange),
      isPinned: isPinnedVersion(packages[pkgName])
    };
  })];
}

function tryFindLatestVersion(pkgName, range) {
  return (0, _getLatestVersion.default)(pkgName, {
    range,
    includeLatest: true
  }).then(({
    latest,
    inRange
  }) => ({
    latest,
    latestInRange: inRange
  })).catch(() => ({
    latest: 'unknown',
    latestInRange: 'unknown'
  }));
}

function isPinnedVersion(version) {
  return /^\d+\.\d+\.\d+/.test(version);
}